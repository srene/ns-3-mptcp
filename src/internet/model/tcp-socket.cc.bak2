/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2007 INRIA
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
 */

#include "ns3/object.h"
#include "ns3/log.h"
#include "ns3/uinteger.h"
#include "ns3/double.h"
#include "ns3/boolean.h"
#include "ns3/trace-source-accessor.h"
#include "ns3/nstime.h"
#include "tcp-socket.h"
#include "tcp-l4-protocol.h"
#include "ns3/inet-socket-address.h"
#include "ns3/inet6-socket-address.h"
#include "ns3/abort.h"

NS_LOG_COMPONENT_DEFINE ("TcpSocket");

namespace ns3 {

NS_OBJECT_ENSURE_REGISTERED (TcpSocket);


TypeId
TcpSocket::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::TcpSocket")
    .SetParent<Socket> ()
    .AddAttribute ("SndBufSize",
                   "TcpSocket maximum transmit buffer size (bytes)",
                   UintegerValue (131072), // 128k
                   MakeUintegerAccessor (&TcpSocket::GetSndBufSize,
                                         &TcpSocket::SetSndBufSize),
                   MakeUintegerChecker<uint32_t> ())
    .AddAttribute ("RcvBufSize",
                   "TcpSocket maximum receive buffer size (bytes)",
                   UintegerValue (131072),
                   MakeUintegerAccessor (&TcpSocket::GetRcvBufSize,
                                         &TcpSocket::SetRcvBufSize),
                   MakeUintegerChecker<uint32_t> ())
    .AddAttribute ("SegmentSize",
                   "TCP maximum segment size in bytes (may be adjusted based on MTU discovery)",
                   UintegerValue (536),
                   MakeUintegerAccessor (&TcpSocket::GetSegSize,
                                         &TcpSocket::SetSegSize),
                   MakeUintegerChecker<uint32_t> ())
    .AddAttribute ("SlowStartThreshold",
                   "TCP slow start threshold (bytes)",
                   UintegerValue (0xffff),
                   MakeUintegerAccessor (&TcpSocket::GetSSThresh,
                                         &TcpSocket::SetSSThresh),
                   MakeUintegerChecker<uint32_t> ())
    .AddAttribute ("InitialCwnd",
                   "TCP initial congestion window size (segments)",
                   UintegerValue (1),
                   MakeUintegerAccessor (&TcpSocket::GetInitialCwnd,
                                         &TcpSocket::SetInitialCwnd),
                   MakeUintegerChecker<uint32_t> ())
    .AddAttribute ("ConnTimeout",
                   "TCP retransmission timeout when opening connection (seconds)",
                   TimeValue (Seconds (3)),
                   MakeTimeAccessor (&TcpSocket::GetConnTimeout,
                                     &TcpSocket::SetConnTimeout),
                   MakeTimeChecker ())
    .AddAttribute ("ConnCount",
                   "Number of connection attempts (SYN retransmissions) before returning failure",
                   UintegerValue (6),
                   MakeUintegerAccessor (&TcpSocket::GetConnCount,
                                         &TcpSocket::SetConnCount),
                   MakeUintegerChecker<uint32_t> ())
    .AddAttribute ("DelAckTimeout",
                   "Timeout value for TCP delayed acks, in seconds",
                   TimeValue (Seconds (0.2)),
                   MakeTimeAccessor (&TcpSocket::GetDelAckTimeout,
                                     &TcpSocket::SetDelAckTimeout),
                   MakeTimeChecker ())
    .AddAttribute ("DelAckCount",
                   "Number of packets to wait before sending a TCP ack",
                   UintegerValue (2),
                   MakeUintegerAccessor (&TcpSocket::GetDelAckMaxCount,
                                         &TcpSocket::SetDelAckMaxCount),
                   MakeUintegerChecker<uint32_t> ())
    .AddAttribute ("TcpNoDelay", "Set to true to disable Nagle's algorithm",
                   BooleanValue (true),
                   MakeBooleanAccessor (&TcpSocket::GetTcpNoDelay,
                                        &TcpSocket::SetTcpNoDelay),
                   MakeBooleanChecker ())
    .AddAttribute ("PersistTimeout",
                   "Persist timeout to probe for rx window",
                   TimeValue (Seconds (6)),
                   MakeTimeAccessor (&TcpSocket::GetPersistTimeout,
                                     &TcpSocket::SetPersistTimeout),
                   MakeTimeChecker ())
  ;
  return tid;
}

TcpSocket::TcpSocket (void)
  : m_node(0),
	m_errno (ERROR_NOTERROR),
    m_socketBase (0)


{
  NS_LOG_FUNCTION_NOARGS ();
  //m_socketBase = CreateObject<TcpSocketBase> ();
  m_socketBase->SetSocket(this);
}

TcpSocket::~TcpSocket ()
{
  NS_LOG_FUNCTION_NOARGS ();
  //m_node = 0;

}

void
TcpSocket::SetError(enum SocketErrno errno)
{
	m_errno = errno;
}

/** Associate a node with this TCP socket */
void
TcpSocket::SetNode (Ptr<Node> node)
{
	m_node = node;
	m_socketBase->SetNode(node);
}

/** Associate the L4 protocol (e.g. mux/demux) with this socket */
void
TcpSocket::SetTcp (Ptr<TcpL4Protocol> tcp)
{
	//m_socketBase->SetTcp(tcp);
	m_tcp = tcp;
}

/** Set an RTT estimator with this socket */
void
TcpSocket::SetRtt (Ptr<RttEstimator> rtt)
{
	m_socketBase->SetRtt(rtt);
}


/** Inherit from Socket class: Returns error code */
enum Socket::SocketErrno
TcpSocket::GetErrno (void) const
{
  return m_errno;
}

/** Inherit from Socket class: Returns socket type, NS3_SOCK_STREAM */
enum Socket::SocketType
TcpSocket::GetSocketType (void) const
{
  return NS3_SOCK_STREAM;
}

/** Inherit from Socket class: Returns associated node */
Ptr<Node>
TcpSocket::GetNode (void) const
{
  NS_LOG_FUNCTION_NOARGS ();
  return m_node;
}

/** Inherit from Socket class: Bind socket to an end-point in TcpL4Protocol */
int
TcpSocket::Bind (void)
{
  NS_LOG_FUNCTION (this);
  int value = m_socketBase->Allocate();
  if (value ==-1)
	  m_errno = ERROR_ADDRNOTAVAIL;
  return value;
}

int
TcpSocket::Bind6 (void)
{
  NS_LOG_FUNCTION (this);
  int value = m_socketBase->Allocate6();
  if (value ==-1)
	  m_errno = ERROR_ADDRNOTAVAIL;
  return value;

}

/** Inherit from Socket class: Bind socket (with specific address) to an end-point in TcpL4Protocol */
int
TcpSocket::Bind (const Address &address)
{
  NS_LOG_FUNCTION (this << address);
  int value;

  if (InetSocketAddress::IsMatchingType (address))
    {
      InetSocketAddress transport = InetSocketAddress::ConvertFrom (address);
      Ipv4Address ipv4 = transport.GetIpv4 ();
      uint16_t port = transport.GetPort ();
      if (ipv4 == Ipv4Address::GetAny () && port == 0)
        {
    	  value = m_socketBase->Allocate ();
        }
      else if (ipv4 == Ipv4Address::GetAny () && port != 0)
        {
          value = m_socketBase->Allocate (port);
        }
      else if (ipv4 != Ipv4Address::GetAny () && port == 0)
        {
          value = m_socketBase->Allocate (ipv4);
        }
      else if (ipv4 != Ipv4Address::GetAny () && port != 0)
        {
    	  value = m_socketBase->Allocate (ipv4, port);
        }
      if (value == -1)
        {
          m_errno = port ? ERROR_ADDRINUSE : ERROR_ADDRNOTAVAIL;
          return -1;
        }
    }
  else if (Inet6SocketAddress::IsMatchingType (address))
    {
      Inet6SocketAddress transport = Inet6SocketAddress::ConvertFrom (address);
      Ipv6Address ipv6 = transport.GetIpv6 ();
      uint16_t port = transport.GetPort ();
      if (ipv6 == Ipv4Address::GetAny () && port == 0)
          {
      	  value = m_socketBase->Allocate6 ();
          }
        else if (ipv6 == Ipv4Address::GetAny () && port != 0)
          {
            value = m_socketBase->Allocate6 (port);
          }
        else if (ipv6 != Ipv4Address::GetAny () && port == 0)
          {
            value = m_socketBase->Allocate6 (ipv6);
          }
        else if (ipv6 != Ipv4Address::GetAny () && port != 0)
          {
      	  value = m_socketBase->Allocate6 (ipv6, port);
          }
        if (value == -1)
          {
            m_errno = port ? ERROR_ADDRINUSE : ERROR_ADDRNOTAVAIL;
            return -1;
          }
    }
  else
    {
      m_errno = ERROR_INVAL;
      return -1;
    }

  return value;
}

/** Inherit from Socket class: Initiate connection to a remote address:port */
int
TcpSocket::Connect (const Address & address)
{
  NS_LOG_FUNCTION (this << address);
  int result =  m_socketBase->Connect(address);
  if(result==-1)
		m_errno = ERROR_INVAL;
  return result;

}

/** Inherit from Socket class: Listen on the endpoint for an incoming connection */
int
TcpSocket::Listen (void)
{
  NS_LOG_FUNCTION (this);
  // Linux quits EINVAL if we're not in CLOSED state, so match what they do
  if (m_socketBase->GetState() != TcpSocketBase::CLOSED)
    {
      m_errno = ERROR_INVAL;
      return -1;
    }
  // In other cases, set the state to LISTEN and done
  NS_LOG_INFO ("CLOSED -> LISTEN");
  m_socketBase->SetState(TcpSocketBase::LISTEN);
  return 0;
}

/** Inherit from Socket class: Kill this socket and signal the peer (if any) */
int
TcpSocket::Close (void)
{
	NS_LOG_FUNCTION (this);
	return m_socketBase->Close();
}

/** Inherit from Socket class: Signal a termination of send */
int
TcpSocket::ShutdownSend (void)
{
  NS_LOG_FUNCTION (this);
  m_shutdownSend = true;
  return 0;
}

/** Inherit from Socket class: Signal a termination of receive */
int
TcpSocket::ShutdownRecv (void)
{
  NS_LOG_FUNCTION (this);
  m_shutdownRecv = true;
  return 0;
}

/** Inherit from Socket class: Send a packet. Parameter flags is not used.
    Packet has no TCP header. Invoked by upper-layer application */
int
TcpSocket::Send (Ptr<Packet> p, uint32_t flags)
{
  NS_LOG_FUNCTION (this << p);
  return m_socketBase->Send(p,flags);
}

/** Inherit from Socket class: In TcpSocket, it is same as Send() call */
int
TcpSocket::SendTo (Ptr<Packet> p, uint32_t flags, const Address &address)
{
  return Send (p, flags); // SendTo() and Send() are the same
}

void
TcpSocket::ResetCallback(void)
{
	  Callback<void, Ptr< Socket > > vPS = MakeNullCallback<void, Ptr<Socket> > ();
	  Callback<void, Ptr<Socket>, const Address &> vPSA = MakeNullCallback<void, Ptr<Socket>, const Address &> ();
	  Callback<void, Ptr<Socket>, uint32_t> vPSUI = MakeNullCallback<void, Ptr<Socket>, uint32_t> ();
	  SetConnectCallback (vPS, vPS);
	  SetDataSentCallback (vPSUI);
	  SetSendCallback (vPSUI);
	  SetRecvCallback (vPS);
}
/** Inherit from Socket class: Return data to upper-layer application. Parameter flags
    is not used. Data is returned as a packet of size no larger than maxSize */
Ptr<Packet>
TcpSocket::Recv (uint32_t maxSize, uint32_t flags)
{
  NS_LOG_FUNCTION (this);
  return m_socketBase->Recv(maxSize,flags);

}

/** Inherit from Socket class: Recv and return the remote's address */
Ptr<Packet>
TcpSocket::RecvFrom (uint32_t maxSize, uint32_t flags, Address &fromAddress)
{
  NS_LOG_FUNCTION (this << maxSize << flags);
  return m_socketBase->RecvFrom(maxSize,flags,fromAddress);

}

/** Inherit from Socket class: Get the max number of bytes an app can send */
uint32_t
TcpSocket::GetTxAvailable (void) const
{
  NS_LOG_FUNCTION (this);
  return m_socketBase->GetTxAvailable();
}

/** Inherit from Socket class: Get the max number of bytes an app can read */
uint32_t
TcpSocket::GetRxAvailable (void) const
{
  NS_LOG_FUNCTION (this);
  return m_socketBase->GetRxAvailable();
}

/** Inherit from Socket class: Return local address:port */
int
TcpSocket::GetSockName (Address &address) const
{
	return m_socketBase->GetSocketName(address);
}

/** Inherit from Socket class: Bind this socket to the specified NetDevice */
void
TcpSocket::BindToNetDevice (Ptr<NetDevice> netdevice)
{
  NS_LOG_FUNCTION (netdevice);
  return m_socketBase->BindToNetDevice(netdevice);
}


} // namespace ns3
